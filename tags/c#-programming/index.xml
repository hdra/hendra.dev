<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C#, Programming on hendra.dev</title><link>https://hendra.dev/tags/c#-programming/</link><description>Recent content in C#, Programming on hendra.dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 10 Jun 2012 10:37:00 +0700</lastBuildDate><atom:link href="https://hendra.dev/tags/c#-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Binding in .NET</title><link>https://hendra.dev/blog/softwares/2012/2012-06-10.data-binding-in-net/</link><pubDate>Sun, 10 Jun 2012 10:37:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-06-10.data-binding-in-net/</guid><description>I am now trying to use the concept of MVVM in my applications, as I believe a proper separation of concerns is very important in building an application, as from I personally experienced when developing in PHP with CodeIgniter, it really makes development much easier.
So, I think for an event driven application pattern such as WPF, Silverlight, and also WP7, (maybe Windows 8 as well), it seems pretty obvious to take advantage of the existing abstraction of the framework, so MVVM would go well with these kind of applications.</description></item><item><title>Threading in C#</title><link>https://hendra.dev/blog/softwares/2012/2012-05-31.cs-threading/</link><pubDate>Thu, 31 May 2012 23:05:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-31.cs-threading/</guid><description>Well, this time, I am going to talk about thread, the concept of thread is pretty simple to understand, so I wont explain the here, but you can read more about it in this wiki page. Threading are used quite extensively in most modern computer programs, for example separating threads to handle button clicks on a GUI button from the one that handles data processing, or in chatting programs, where it separates threads to send messages from the one that handles incoming messages and display it on the screen.</description></item><item><title>Implicitly Typed Language and Anonymous Types in C#</title><link>https://hendra.dev/blog/softwares/2012/2012-05-30.implicitly-typed-language-and-anonymous-types-in-c/</link><pubDate>Wed, 30 May 2012 23:16:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-30.implicitly-typed-language-and-anonymous-types-in-c/</guid><description>In C#, there is this var keyword, which allows you to declare a variable without explicitly specifying its data type. It is important to note, that this doesn’t mean that it is dynamically typed, it simply means that the compiler will infer the data type for you, and it is also important to note, that it is strongly typed. So, this code below, will simply create a variable called x, with the data type of string.</description></item><item><title>Lambda Expression with C#</title><link>https://hendra.dev/blog/softwares/2012/2012-05-30.lambda-expression/</link><pubDate>Wed, 30 May 2012 21:40:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-30.lambda-expression/</guid><description>Previous in my post regarding delegate, I talked a little about anonymous method that can be used with delegates, there are other forms to declare inline functions. Both of them are collectively known as anonymous functions of C#. Here is one example that shows how different method assignments are used with delegate.
:::csharp class SampleClass { public delegate void SampleDelegate(string s); public void SampleMethod(string s) { Console.WriteLine(s); } public static void Main(string[] args) { SampleDelegate a = SampleMethod; SampleDelegate b = new SampleDelegate(SampleMethod); SampleDelegate c = delegate(string s){Console.</description></item><item><title>Events in C#</title><link>https://hendra.dev/blog/softwares/2012/2012-05-30.events-in-c/</link><pubDate>Wed, 30 May 2012 00:27:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-30.events-in-c/</guid><description>Alright, last time I posted about Delegate, and together with event, they are one of the most important concept to understand in event driven application framework, such as WPF, Silverlight, and Silverlight for WP7, and maybe even WinRT as well (I haven’t tried it), so I believe it is important to understand how it work, especially when these two are pretty closely related.
I find the explanation on MSDN is pretty easy to understand, Event is a way for a class to provide notifications to clients when something interesting happens.</description></item><item><title>Some Stuff I Didn’t Know About String in C#</title><link>https://hendra.dev/blog/softwares/2012/2012-05-25.some-stuff-i-didnt-know-about-string-in-c/</link><pubDate>Fri, 25 May 2012 23:08:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-25.some-stuff-i-didnt-know-about-string-in-c/</guid><description>Well, its a bit strange getting to know something that I’ve used extensively for quite a while, but there are indeed some things that feels revealing.
First of all, I knew that strings is a little bit special, in a way that it is a reference type, but it behaves very much like a value type, for example:
:::csharp SomeClass a = new SomeClass(); a.age = 18; SomeClass b = a; b.</description></item><item><title>Some Standard C# Object Methods That You Might Want to Override</title><link>https://hendra.dev/blog/softwares/2012/2012-05-25.some-standard-c-object-methods-that-you-might-want-to-override/</link><pubDate>Fri, 25 May 2012 22:22:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-25.some-standard-c-object-methods-that-you-might-want-to-override/</guid><description>Alright, I’ll get it straight to the point, since this is just a note to myself anyway,
First one, the ToString() :
:::csharp class YourClass{ private string name; private int age; public override string ToString() { return &amp;quot;Name: &amp;quot;+this.name+&amp;quot;,Age: &amp;quot;+this.age.toString(); } } The reason to this is, simple, to have an easy way to get a string representation of your object. Of course, in a way, you can also create a new method to return the same thing, but it is a good idea to do it the “C# way”, and the ToString method is always there, so why create two methods that serve the same purpose?</description></item><item><title>C# – Optional Arguments and Constructor Chaining</title><link>https://hendra.dev/blog/softwares/2012/2012-05-22.csharp-optional-arguments-and-constructor-chaining/</link><pubDate>Tue, 22 May 2012 23:19:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-22.csharp-optional-arguments-and-constructor-chaining/</guid><description>Learned something new about C# today, first thing is Constructor Chaining. Constructor chaining enables constructors to call another overloaded constructor, with it, the amount of duplicate code can be reduced significantly, here is an example:
:::csharp class Person{ string name; int age; string address; public Person(string name):this(string.Empty,0,string.Empty) { } public Person(string name):this(name,0,string.Empty) { } public Person(string name, int age):this(name,age,string.Empty) { } public Person(string name, int age, string address) { this.name=name; this.</description></item><item><title>C# Back to Basics</title><link>https://hendra.dev/blog/softwares/2012/2012-05-20.c-back-to-basics/</link><pubDate>Sun, 20 May 2012 23:12:00 +0700</pubDate><guid>https://hendra.dev/blog/softwares/2012/2012-05-20.c-back-to-basics/</guid><description>I have been programming C# for quite some time, but when I think about it, I have never really tried to learn C# as a language, instead what I’ve been playing with around are mostly the .NET framework itself, this result in me having to guess the magic behind many of the operations in the programs I wrote myself, and that sucks.
I think this is a problem that plagues many .</description></item></channel></rss>