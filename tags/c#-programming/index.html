<!doctype html><html><head><link href="https://fonts.googleapis.com/css?family=Gentium+Book+Basic|Merriweather:400,300" rel=stylesheet type=text/css><link rel=stylesheet href=/styles/style.min.5e7be87fa7c7ef4bb4c12c96363c550ae3c76c0dabc2981aca7d478ab4d633b9.css></head><body><div class=container><header class=blog-header><h1><a href=https://hendra.dev/>hendra.dev</a></h1><p>A work in progress</p><nav><ul class=nav><li><a href=/blog/>blogs</a></li><li><a href=/notes/>notes</a></li></ul></nav></header><div class=post-list><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-06-10.data-binding-in-net/>Data Binding in .NET</a></h2><time datetime=2012-06-10T10:37:00+0700>Jun 10, 2012</time><div class=excerpt>I am now trying to use the concept of MVVM in my applications, as I believe a proper separation of concerns is very important in building an application, as from I personally experienced when developing in PHP with CodeIgniter, it really makes development much easier.
So, I think for an event driven application pattern such as WPF, Silverlight, and also WP7, (maybe Windows 8 as well), it seems pretty obvious to take advantage of the existing abstraction of the framework, so MVVM would go well with these kind of applications.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-31.cs-threading/>Threading in C#</a></h2><time datetime=2012-05-31T23:05:00+0700>May 31, 2012</time><div class=excerpt>Well, this time, I am going to talk about thread, the concept of thread is pretty simple to understand, so I wont explain the here, but you can read more about it in this wiki page. Threading are used quite extensively in most modern computer programs, for example separating threads to handle button clicks on a GUI button from the one that handles data processing, or in chatting programs, where it separates threads to send messages from the one that handles incoming messages and display it on the screen.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-30.implicitly-typed-language-and-anonymous-types-in-c/>Implicitly Typed Language and Anonymous Types in C#</a></h2><time datetime=2012-05-30T23:16:00+0700>May 30, 2012</time><div class=excerpt>In C#, there is this var keyword, which allows you to declare a variable without explicitly specifying its data type. It is important to note, that this doesn’t mean that it is dynamically typed, it simply means that the compiler will infer the data type for you, and it is also important to note, that it is strongly typed. So, this code below, will simply create a variable called x, with the data type of string.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-30.lambda-expression/>Lambda Expression with C#</a></h2><time datetime=2012-05-30T21:40:00+0700>May 30, 2012</time><div class=excerpt>Previous in my post regarding delegate, I talked a little about anonymous method that can be used with delegates, there are other forms to declare inline functions. Both of them are collectively known as anonymous functions of C#. Here is one example that shows how different method assignments are used with delegate.
:::csharp class SampleClass { public delegate void SampleDelegate(string s); public void SampleMethod(string s) { Console.WriteLine(s); } public static void Main(string[] args) { SampleDelegate a = SampleMethod; SampleDelegate b = new SampleDelegate(SampleMethod); SampleDelegate c = delegate(string s){Console.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-30.events-in-c/>Events in C#</a></h2><time datetime=2012-05-30T00:27:00+0700>May 30, 2012</time><div class=excerpt>Alright, last time I posted about Delegate, and together with event, they are one of the most important concept to understand in event driven application framework, such as WPF, Silverlight, and Silverlight for WP7, and maybe even WinRT as well (I haven’t tried it), so I believe it is important to understand how it work, especially when these two are pretty closely related.
I find the explanation on MSDN is pretty easy to understand, Event is a way for a class to provide notifications to clients when something interesting happens.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-25.some-stuff-i-didnt-know-about-string-in-c/>Some Stuff I Didn’t Know About String in C#</a></h2><time datetime=2012-05-25T23:08:00+0700>May 25, 2012</time><div class=excerpt>Well, its a bit strange getting to know something that I’ve used extensively for quite a while, but there are indeed some things that feels revealing.
First of all, I knew that strings is a little bit special, in a way that it is a reference type, but it behaves very much like a value type, for example:
:::csharp SomeClass a = new SomeClass(); a.age = 18; SomeClass b = a; b.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-25.some-standard-c-object-methods-that-you-might-want-to-override/>Some Standard C# Object Methods That You Might Want to Override</a></h2><time datetime=2012-05-25T22:22:00+0700>May 25, 2012</time><div class=excerpt>Alright, I’ll get it straight to the point, since this is just a note to myself anyway,
First one, the ToString() :
:::csharp class YourClass{ private string name; private int age; public override string ToString() { return "Name: "+this.name+",Age: "+this.age.toString(); } } The reason to this is, simple, to have an easy way to get a string representation of your object. Of course, in a way, you can also create a new method to return the same thing, but it is a good idea to do it the “C# way”, and the ToString method is always there, so why create two methods that serve the same purpose?</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-22.csharp-optional-arguments-and-constructor-chaining/>C# – Optional Arguments and Constructor Chaining</a></h2><time datetime=2012-05-22T23:19:00+0700>May 22, 2012</time><div class=excerpt>Learned something new about C# today, first thing is Constructor Chaining. Constructor chaining enables constructors to call another overloaded constructor, with it, the amount of duplicate code can be reduced significantly, here is an example:
:::csharp class Person{ string name; int age; string address; public Person(string name):this(string.Empty,0,string.Empty) { } public Person(string name):this(name,0,string.Empty) { } public Person(string name, int age):this(name,age,string.Empty) { } public Person(string name, int age, string address) { this.name=name; this.</div></article><article class=post-overview><h2><a href=https://hendra.dev/blog/softwares/2012/2012-05-20.c-back-to-basics/>C# Back to Basics</a></h2><time datetime=2012-05-20T23:12:00+0700>May 20, 2012</time><div class=excerpt>I have been programming C# for quite some time, but when I think about it, I have never really tried to learn C# as a language, instead what I’ve been playing with around are mostly the .NET framework itself, this result in me having to guess the magic behind many of the operations in the programs I wrote myself, and that sucks.
I think this is a problem that plagues many .</div></article></div></div></body></html>